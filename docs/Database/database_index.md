# 데이터베이스 인덱스와 디스크 I/O 최적화
#인덱스 #BTree #디스크IO #데이터베이스 #성능튜닝

**Summary**: 이 문서는 데이터베이스에서 인덱스의 역할과 디스크 I/O의 중요성을 설명하며, B-Tree와 B+Tree 구조, 디스크 I/O의 종류와 효율성, 그리고 인덱스의 다양한 유형과 사용법을 다룹니다.

## 인덱스란?
인덱스는 데이터베이스에서 데이터를 빠르게 검색하기 위해 추가적인 저장 공간과 작업을 활용하여 만든 데이터 구조입니다.

### B-Tree와 B+Tree
- **B-Tree**: 균형 있는 높이를 유지하는 트리 구조로, 최악의 경우에도 O(logn)의 검색 성능을 보장합니다. 그러나 수정 및 삭제 시 재구성이 필요합니다.
- **B+Tree**: B-Tree의 변형으로, 데이터는 리프 노드에만 저장되며, 리프 노드 간 링크드 리스트로 연결되어 있어 순차적 및 범위 검색에 유리합니다.

## 디스크 읽기 방식
데이터베이스 성능 튜닝에서 디스크 I/O를 줄이는 것이 중요합니다.

### DISK I/O란?
디스크에서 데이터를 읽거나 쓰는 작업을 의미합니다.

### 디스크의 종류
1. **HDD**: 플래터를 회전시켜 데이터를 찾습니다.
2. **SSD**: 플래터 대신 플래시 메모리를 사용하여 기계적 회전 없이 데이터를 빠르게 읽고 씁니다.

### 랜덤 I/O vs 순차 I/O
- **순차 I/O**: 연속된 블록에 데이터를 저장하고 읽는 방식으로, 시스템 콜이 적어 빠릅니다.
- **랜덤 I/O**: 여러 위치에서 데이터를 불규칙하게 읽고 쓰는 방식으로, 시스템 콜이 많아 느립니다.

## 인덱스의 종류와 사용
인덱스는 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조로, 정렬된 리스트처럼 동작합니다.

### 인덱스의 종류
1. **프라이머리키 인덱스 (클러스터형 인덱스)**: 프라이머리키로 자동 생성되며, 데이터가 리프 노드에 저장됩니다.
2. **세컨더리 인덱스**: 프라이머리키를 제외한 나머지 인덱스로, 데이터 대신 프라이머리키 값만 저장됩니다.

### 데이터 저장 방식
- **B-Tree**: 원래의 값을 이용해 인덱싱합니다.
- **Hash**: 해시 함수를 사용해 인덱싱합니다.

### 인덱스 키 관리
- **추가**: 인덱스 키를 추가합니다.
- **삭제**: 마킹 후 방치하거나 재활용합니다.
- **변경**: 삭제 후 삽입합니다.

## 페이지와 블록
InnoDB 스토리지 엔진의 기본 저장 단위는 페이지와 블록입니다. 모든 읽기/쓰기 작업은 페이지 단위로 처리됩니다.

### B-Tree와 디스크 깊이
- **트리 깊이**: 깊을수록 디스크 읽기 횟수가 증가하여 성능이 저하됩니다.
- **유니크한 값의 개수**: 인덱스나 쿼리의 효율성에 영향을 미칩니다.

## 인덱스 스캔의 종류
1. **인덱스 레인지 스캔**: 여러 레코드를 읽을 때 사용합니다.
2. **인덱스 풀 스캔**: 인덱스를 처음부터 끝까지 읽습니다.
3. **루스 인덱스 스캔**: 필요하지 않은 인덱스 키값을 무시하고 읽습니다.
4. **인덱스 스킵 스캔**: 특정 조건에 따라 인덱스를 건너뛰며 읽습니다.

## Key Points
- 인덱스는 데이터베이스 검색 속도를 향상시킵니다.
- B-Tree와 B+Tree는 각각의 장단점이 있습니다.
- 디스크 I/O는 데이터베이스 성능에 큰 영향을 미칩니다.
- 인덱스의 종류와 사용법에 따라 성능이 달라질 수 있습니다.
- 인덱스 스캔 방식은 쿼리 효율성을 결정합니다.

## Follow-up Questions / Discussion Points
1. B-Tree와 B+Tree의 차이점은 무엇이며, 각각의 장단점은 무엇인가요?
2. 디스크 I/O에서 순차 I/O가 랜덤 I/O보다 빠른 이유는 무엇인가요?
3. 인덱스의 종류에 따라 데이터베이스 성능에 어떤 영향을 미칠 수 있나요?
4. 인덱스 스캔 방식 중 가장 효율적인 방법은 무엇이며, 그 이유는 무엇인가요?
5. 데이터베이스에서 인덱스를 추가할 때 고려해야 할 사항은 무엇인가요?