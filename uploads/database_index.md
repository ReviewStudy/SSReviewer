
## 인덱스란?
- 인덱스는 데이터베이스에서 데이터를 빠르게 검색을 하기위해 저장공간과 추가적인 작업을 하여 만든 데이터 구조입니다!

B-Tree? B+Tree
- B-tree는 일반적인 트리 구조에서  균형있는 높이를 유지하는 트리구조입니다
- 일반적이니 트리에서는 한쪽에 데이터가 편향되어 있는경우 평균 O(logn)에서 O(n)까지 늘어날 수 있습니다
- 하지만 B-Tree는 균형있는 구조를 통해서 최악의 경우에도 O(logn)을 만들 수 있습니다
- 노드의 자식수중 최댓값을 K라고 하면 K차 B-Tree라고 부릅니다
- 하지만 수정, 삭제 연산에 있어서는 계속해서 재구성을 해야하는 단점이 있습니다

B+Tree같은 경우에는 B-Tree에서 또 변형된 구조로써 각 노드에서 데이터를 가지고 있었던 B-Tree가 아니라 리프노드에서만 데이터를 가지고 있도록 하고 그 리프노드끼리는 링크드리스트로 연결되어 순차적인 검색과 범위검색에 더 효과적인 자료구조입니다. 

Mysql B+Tree

https://rebro.kr/169
https://rebro.kr/167
https://mangkyu.tistory.com/96
https://mangkyu.tistory.com/286


## 디스크 읽기 방식

데이터베이스의 성능 튜닝에서 가장 중요한 것은 디스크IO를 줄이는 것입니다!

DISK I/O란 무엇인가? 
- 디스크에서 데이터를 읽거나 쓰는 작업!

Disk의 종류
1. HDD 실제 저장용 플래터(원판)을 돌리면서 데이터를 찾는 방식이다
2.  SSD는 원판을 제거하고 플래시메모리를 장착하여 기계적으로 회전없이 더 빨리 데이터를 읽고 쓸 수 있다
	1. 전원이 공급되지 않아도 데이터가 삭제되지 않는다
		1. 왜? NAND Flash Memory - 전하 저장 방식

> 데이터베이스에서는 대부분의 작업은 랜덤 I/O를 통해서 작은 데이터를 읽고 쓰는 작업이고 
   SSD의 랜덤 I/O가 HDD의 랜덤 I/O 보다 더 빠르다
   고로 보통 SSD를 많이 사용한다 

랜덤I/O vs 순차I/O
그렇다면 랜덤I/O는 무엇이고 순차I/O는 무엇일까?
순차I/O는 **데이터를 디스크의 연속된 블록에 저장하고, 연속적으로 읽거나 쓰는 방식**.
랜덤I/O는 **디스크의 여러 위치에서 불규칙하게 데이터를 읽거나 쓰는 방식**.

보통 순차I/O가 랜덤 I/O보다 더 빠른데 이유가 무엇인가?

순차I/O가 더 빠른이유
- 순차I/O는 3개의 페이지를 기록하기 위해서는 1번의 시스템콜을 호출한다
- 하지만 랜덤I/O는 3개의 페이지 기록을 위해 3번의 시스템 콜을 해야한다
![[Pasted image 20250214154734.png]]


>시스템 콜이란? 
사용자 프로세스가 커널에 직접 접근할 수 없기에 OS 커널을 통해서 하드웨어르 조작하는 요청 방식

즉, 디스크에 저장할때 OS에 write() 시스템 콜을 호출을 해야한다! 

여기서 왜 순차I/O는 한번의 write() 함수의 호출로 가능한것인가?
- 커널은 여러 페이지를 하나의 연속된 블록으로 묶어서 처리할 수 있고 그렇기 때문에 연속적인 페이지를 기록하는데 연속적인 데이터 블록을 빠르게 쓰거나 읽을 수 있다는 것이다!

```
write(fd, buffer, 3 * PAGE_SIZE);
```

하지만 랜덤 I/O는 각 페이지가 서로 다른 물리적 위치에 저장이 되고 각 페이지마다 별도의 시스템 콜과 I/O요청을 해야하기 때문에 3번을 보내야한다

```
write(fd, buffer1, PAGE_SIZE);
write(fd, buffer2, PAGE_SIZE);
write(fd, buffer3, PAGE_SIZE);
```


#### 정리
HDD에서 순차IO가 랜덤IO보다 속도가 더 빠른 이유는 
플래터의 헤드를 계속해서 이동을 해야하기 때문
순차 io는 연속된 페이지를 한번에 읽기 때문에 더 빠르다

SSD에서 순차IO가 랜덤IO보다 빠른 이유
1. SSD에서의 데이터 단위는 페이지이고 이 페이지들을 블록단위로 관리
- 랜덤 IO는 각기 다른 블록에 있는 데이터를 읽어야하기 때문에 블록 접근이 더 많아짐
- 순차는 반대로 연속된 페이지를 한번에 읽을 수 있습니다. 

2. FTL 으로 논리적 주소를 물리적 플래시 메모리 주소로 변환을 하게 되는데 랜덤IO는 여러개의 논리적 주소를 찾고 매핑하는 과정이 증가하기 때문입니다.

## 인덱스
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 일반적으로 **Sorted List(정렬된 리스트)처럼 동작**하며, 테이블의 데이터를 정렬된 형태로 저장하여 검색을 최적화한다.

SortedList - 인덱스 자료구조 
ArrayList- 데이터파일

이라고 생각을 해보면 Sorted List의 장단점은

Sorted List -> 데이터가 저장될때마다 정렬을 해야하므로 느리지만 검색할때는 정렬이 되어있기 때문에 빠르다 라는 것이다 

즉! 다음을 고려해야한다
1. 인덱스를 하나 추가할지 말지를 결정하는 것은 데이터의 저장 속도를 어디까지 희생할 수 있는가? 
2. 읽기를 얼마나 빠르게 만들어야하나?

WHERE 조건 절에 사용된다고 해도 모두 인덱스로 하면 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과가 난다

#### 인덱스의 종류
1. 프라이머리키 인덱스(클러스터형 인덱스)
	1. 프라이머리키로 자동 생성되는 인덱스
	2. 데이터 자체가 리프노드에 저장이 된다
2. 세컨더리 인덱스
	1. 프라이머리키 제외한 나머지 모든 인덱스
	2. 데이터 자체는 저장되지 않고 프라이머리키의 값만 저장이 된다
		1. 즉 데이터를 가져오려면 프라이머리키를 이용해서 다시 클러스터형 인덱스를 조회해야한다!

디펄트로 클러스터링을 사용-> 비슷한 값들을 모은다

#### 데이터 저장 방식

데이터저장 방식 - B-Tree, Hash
B-Tree 원래의 값을 이용해서 인덱싱

데이터파일의 레코드는 정렬되어있지 않고 임의의순서
인덱스의 리프노드에서 데이터파일에 저장된 레코드의 주소
![[Pasted image 20250214133802.png]]

인덱스 키 추가!
인덱스키 삭제
- 마킹만 한다 -> 방치 재활용
인덱스 키 변경 -> 삭제후 삽입

인덱스 키 검색
- select, update, delete
- 100%일치또는 앞부분
- 키값의 변형이 있으면 빠른 검색 기능 사용할 수 없다
검색시에는 넥스트키락으로 레코드로 잠근다

### 페이지와 블록
- InnoDB 스토리지 엔진의 기본 저장 단위는 페이지와 블록이다
- 모든 읽기/쓰기 작업은 최소 작업 단위인 페이지 단위로 처리가 된다
- 기본 페이지: 16KB, 한 레코드가 28KB정도 한다고하면(인덱스 16바이트 + 주소12바이트) 585개 레코드 저장가능하다

 **B-Tree와 디스크 깊이**
- **B-Tree 깊이는 직접 제어 불가**.
- **트리 깊이가 깊을수록(높을수록), 디스크 읽기 횟수가 증가** → 성능 저하.
- 인덱스가 효율적으로 설계되지 않으면 트리 탐색 비용이 증가.

디스크 깊이 가 깊어지면 디스크 읽기 가 더많이 필요하다 왜?
- 디스크 깊이란 무엇인가?
	- 데이터가 저장된 데이스크에서 특정 데이터를 찾기 위해 이동해야하는 레벨
	- 즉 더 많은 디스크 블록을 읽어야한다!

인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미친다

왜? 

인덱스를 통해 레코드 1건을 읽는것이 테이블에서 직접 레코드 1건을 읽는것보다 4-5배 정도 더 많이 드는작업이다
인덱스를 통해 읽어야할 레코드가 전체 테이블 레코드의  20 -25%를 넘어가면 인덱스를 사용하지 말고 직접 읽어서 필터링

왜?

1. 인덱스를 사용하는 경우

인덱스를 사용할때 과정을 보면 인덱스 노드를 탐색하며 조건에 맞는 PK를 찾는다
이 PK를 이용해서 테이블에서 실제 데이터를 조회하게 된다 -> 즉 두번의 Random I/O가 필요하게 된다

2. 테이블을 직접 읽는 경우

테이블을 순차I/O로 읽는다
한번에 연속된 블록을 읽어서 속도가 더 빠르다

고로 조회해야하는 데이터가 20~25%가 늘어난다고 할때 랜덤I/O가 너무 많아져서 순차I/O로 찾는게 나을수도 있다

그렇다면 스캔의 종류에는 어떤것이 있는가? 꼭 바로 테이블 스캔을 해야하는가?
1. 인덱스 레인지 스캔
- 레코드 1건 이상읽을때
- 리프노드까지가야지 레코드의 시작지점을 알 수 있다
- 시작할 위치를 찾고 그때부터 순서대로 읽으면 된다
- 멈춰야하면 지금까지 읽은 레코드 반환한다
- 하지만 결국 데이터파일에서 레코드를 읽어오는 과정이 필요하다
- 레코드 한건한건 마다 랜덤 I/O가 발생한다. 
- 3건의 레코드가 일치하면  랜덤io가 3번 일어난다는것이다
- 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 상상 빨라진다

1. 인덱스 풀 스캔
- 처음부터 끝까지 인덱스를 모두 읽는 방식을 인덱스 풀스캔이라고 한다
- 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌경우 사용
- 일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 인덱스만 읽는게 효율적
- 인덱스에 명시된 칼럼만으로 적ㄴ을 처리할 수있는경우 활용
- 데이터레코드까지 읽어야하면 사용되지 않는다

1. 루스 인덱스 스캔
- 듬성듬성하게 인덱스를 읽는것
- 중간에 필요하지 않은 인덱스 키값은 무시
- groupby max, min함수에 대해 최적화
- 

2. 인덱스 스킵 스캔


